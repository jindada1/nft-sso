const MainSecp = artifacts.require("MainSecp");
const utils = require("../utils")
const secp256k1 = require("../curves/secp256k1")
const Signer = require("../signencrypt").Signer

const signer = new Signer(secp256k1);

contract('MainSecp', (accounts) => {

    let Alice = secp256k1.keypair(utils.prikeys[0])
    let Bob = secp256k1.keypair(utils.prikeys[1])

    let r   = utils.randomBytes(32);
    let R   = secp256k1.drivePub(r)
    let M = utils.asciiToHex("Hello Bob")
    let ID_A = Alice.pubkey[0]
    let ID_B = Bob.pubkey[0]
    let w_A = Alice.prikey;
    let W_A = Alice.pubkey;
    let w_B = Bob.prikey
    let W_B = Bob.pubkey
    

    it(`drivePubkey`, async () => {

        const main = await MainSecp.deployed();

        const pubkey = await main.drivePubkey(Alice.prikey);
        let pub = pubkey.map(utils.bnToHex)
        
        assert.deepEqual(pub, Alice.pubkey, `wrong response:`);
    });

    
    it(`oneAndRightHalf`, async () => {

        const main = await MainSecp.deployed();

        let RhSol = await main.oneAndRightHalf(Bob.prikey);
        RhSol = utils.bnToHex(RhSol)
        
        const RhJs = utils.oneAndRightHalf(Bob.prikey);
        // console.log(RhSol, RhJs);

        assert.equal(RhSol, RhJs, 'ooops');
    });


    it(`ECCMul`, async () => {

        const main = await MainSecp.deployed();

        let RSol = await main.ECCMul(R, 10);
        RSol = RSol.map(utils.bnToHex)

        const RJS = secp256k1.mulPoint(R, 10);
        // console.log(RSol, RJS);

        assert.deepEqual(RJS.map(BigInt), RSol.map(BigInt), 'ooops');
    });


    it(`ECCAdd`, async () => {

        const main = await MainSecp.deployed();

        let sumSol = await main.ECCAdd(Alice.pubkey, Bob.pubkey);
        sumSol = sumSol.map(utils.bnToHex)

        const sumJs = secp256k1.addPoints(Alice.pubkey, Bob.pubkey);
        // console.log(sumSol, sumJs);

        assert.deepEqual(sumSol.map(BigInt), sumJs.map(BigInt), 'ooops');
    });


    it(`AliceK`, async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256[2] W_B  - Bob's public key
         */
        const K_BN = await main.AliceK(r, w_A, W_B);
        // console.log(K_BN);
        /**
         * @return uint256[2] K
         */
        let K = K_BN.map(utils.bnToHex)
        
        let [x_RR_js, K_js] = signer.AliceK(r, w_A, W_B)
        
        // console.log({K, K_js});
        assert.deepEqual(K.map(BigInt), K_js.map(BigInt), 'AliceK Wrong Answer');
    });


    it(`BobK`, async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256[2] R    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    w_B  - Bob's private key
         */
        const K_BN = await main.BobK(R, W_A, w_B);
        
        /**
         * @return uint256[2] K
         */
        let K = K_BN.map(utils.bnToHex)
        
        let [x_RR_js, K_js] = signer.BobK(R, W_A, w_B);
        
        // console.log({K, K_js});
        assert.deepEqual(K.map(BigInt), K_js.map(BigInt), 'BobK Wrong Answer');
    });


    it('signCryption-js & unSignCryption-sol', async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        let {R, C, s} = signer.signCryption(r, w_A, ID_A, M, W_B, ID_B);
        // console.log({R, C, s});
        
        /**
         * @param uint256[2] R    - signature
         * @param uint256    C    - ciphertext
         * @param uint256    s    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    w_B  - Bob's private key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        const verification = await main.unSignCryption(R, C, s, W_A, ID_A, w_B, ID_B);
        
        /**
         * @return uint256 M   - Decrypts the ciphertext C
         * @return bool    v   - result of verification(True/False).
         */
        
        let M_sol = utils.bnToHex(verification.M)
        let v_sol = verification.v
        // console.log({M_sol, v_sol});

        assert.equal(v_sol, true, 'oops');
        assert.equal(M_sol, M, 'oops');
    });


    it('signCryption-js & verifySignature-sol', async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        let {R, C, s} = signer.signCryption(r, w_A, ID_A, M, W_B, ID_B);
        // console.log({R, C, s});
        
        /**
         * @param R    - signature
         * @param C    - ciphertext
         * @param s    - signature
         * @param W_A  - Alice's public key
         * @param ID_A - Alice's unique identifiers
         * @param ID_B - Bob's unique identifiers
         */
        const validation = await main.verifySignature(R, C, s, W_A, ID_A, ID_B);
        
        /**
         * @return bool    v   - result of verification(True/False).
         */
        // console.log({validation});

        assert.equal(validation, true, 'oops');
    });

    it(`signCryption-sol & unSignCryption-sol`, async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        const signature = await main.signCryption(r, w_A, ID_A, M, W_B, ID_B);
        
        /**
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        // console.log({R, C, s});
        
        /**
         * @param uint256[2] R    - signature
         * @param uint256    C    - ciphertext
         * @param uint256    s    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    w_B  - Bob's private key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        const verification = await main.unSignCryption(R, C, s, W_A, ID_A, w_B, ID_B);
        
        /**
         * @return uint256 M   - Decrypts the ciphertext C
         * @return bool    v   - result of verification(True/False).
         */
        
        let M_sol = utils.bnToHex(verification.M)
        let v_sol = verification.v
        // console.log({M_sol, v_sol});

        assert.equal(v_sol, true, 'oops');
        assert.equal(M_sol, M, 'oops');
    });
    
    
    it(`signCryption-sol & verifySignature-sol`, async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        const signature = await main.signCryption(r, w_A, ID_A, M, W_B, ID_B);
        
        /**
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        // console.log({R, C, s});
        
        /**
         * @param R    - signature
         * @param C    - ciphertext
         * @param s    - signature
         * @param W_A  - Alice's public key
         * @param ID_A - Alice's unique identifiers
         * @param ID_B - Bob's unique identifiers
         */
         const validation = await main.verifySignature(R, C, s, W_A, ID_A, ID_B);
         
        /**
         * @return bool    v   - result of verification(True/False).
         */
        // console.log({validation});

        assert.equal(validation, true, 'oops');
    });
    
    
    it('signCryption-sol & verifySignature-js', async () => {

        const main = await MainSecp.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         */
        const signature = await main.signCryption(r, w_A, ID_A, M, W_B, ID_B);
        
        /**
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        // console.log({R, C, s});
        
        /**
         * @param R    - signature
         * @param C    - ciphertext
         * @param s    - signature
         * @param W_A  - Alice's public key
         * @param ID_A - Alice's unique identifiers
         * @param ID_B - Bob's unique identifiers
         */
        const validation = signer.verifySignature(R, C, s, W_A, ID_A, ID_B);
        
        /**
         * @return bool    v   - result of verification(True/False).
         */
        assert.equal(validation, true, 'oops');
    });
});